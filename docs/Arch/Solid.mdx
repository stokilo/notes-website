---
sidebar_label: 'Solid'
---

# Introduction To What We Built

import EmbeddedBoard from "../components/EmbeddedBoard";

<EmbeddedBoard
  serviceUrl="https://board.slawomirstec.com"
  importUrl="https://notes.slawomirstec.com/diagrams/solid.json"
/>

## S â€“ Single Responsibility Principle

OczywiÅ›cie. Z przyjemnoÅ›ciÄ… wytÅ‚umaczÄ™ **ZasadÄ™ Jednej OdpowiedzialnoÅ›ci (Single Responsibility Principle - SRP)** na praktycznym przykÅ‚adzie z uÅ¼yciem **Javy i frameworka Spring**, ktÃ³ry odzwierciedla realne scenariusze spotykane w pracy.

### Wprowadzenie do zasady

**Zasada Jednej OdpowiedzialnoÅ›ci** mÃ³wi, Å¼e:

> **Klasa powinna mieÄ‡ tylko jeden powÃ³d do zmiany.**

Co to jest "powÃ³d do zmiany"? W kontekÅ›cie aplikacji biznesowej, najlepiej myÅ›leÄ‡ o tym jako o **odpowiedzialnoÅ›ci wobec rÃ³Å¼nych "aktorÃ³w" lub dziaÅ‚Ã³w w organizacji**. JeÅ›li zmiana wymagaÅ„ od dziaÅ‚u marketingu (np. treÅ›Ä‡ maila powitalnego) oraz zmiana wymagaÅ„ od dziaÅ‚u IT (np. migracja bazy danych) zmusza CiÄ™ do modyfikacji tej samej klasy, to ta klasa Å‚amie SRP. Ma co najmniej dwa "powody do zmiany".

---

### Scenariusz: Rejestracja nowego uÅ¼ytkownika w aplikacji e-commerce

Proces rejestracji uÅ¼ytkownika w systemie opartym na Spring Boot skÅ‚ada siÄ™ z kilku krokÃ³w:
1.  Odebranie Å¼Ä…dania HTTP z danymi (JSON).
2.  Walidacja danych wejÅ›ciowych (czy email jest poprawny, hasÅ‚o silne itp.).
3.  Sprawdzenie logiki biznesowej (czy uÅ¼ytkownik o tym e-mailu juÅ¼ nie istnieje).
4.  Zapisanie nowego uÅ¼ytkownika w bazie danych (hasÅ‚o musi byÄ‡ zahaszowane).
5.  WysÅ‚anie asynchronicznego e-maila powitalnego.

---

### ZÅ‚y przykÅ‚ad - Naruszenie zasady SRP w komponencie Spring

PoczÄ…tkujÄ…cy programista mÃ³gÅ‚by umieÅ›ciÄ‡ caÅ‚Ä… tÄ™ logikÄ™ w jednym komponencie `@Service`.

**Kod (po angielsku):**

```java
// ğŸ‘ BAD EXAMPLE - VIOLATES SRP

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository; // ZaÅ‚Ã³Å¼my, Å¼e to interfejs JpaRepository

    @Autowired
    private JavaMailSender mailSender; // BezpoÅ›rednia zaleÅ¼noÅ›Ä‡ od implementacji mailowej

    // Metoda, ktÃ³ra robi wszystko
    public void registerUser(String email, String rawPassword) {

        // 1. OdpowiedzialnoÅ›Ä‡: Walidacja danych wejÅ›ciowych
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("Invalid email format.");
        }
        if (rawPassword == null || rawPassword.length() < 8) {
            throw new IllegalArgumentException("Password must be at least 8 characters long.");
        }

        // 2. OdpowiedzialnoÅ›Ä‡: Logika biznesowa (sprawdzanie duplikatÃ³w)
        if (userRepository.findByEmail(email).isPresent()) {
            throw new IllegalStateException("User with this email already exists.");
        }

        // 3. OdpowiedzialnoÅ›Ä‡: Haszowanie hasÅ‚a (szczegÃ³Å‚ implementacyjny)
        String hashedPassword = BCrypt.hashpw(rawPassword, BCrypt.gensalt());

        // 4. OdpowiedzialnoÅ›Ä‡: Tworzenie i zapis do bazy danych
        User user = new User();
        user.setEmail(email);
        user.setPassword(hashedPassword);
        userRepository.save(user);

        // 5. OdpowiedzialnoÅ›Ä‡: WysyÅ‚anie powiadomienia e-mail
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom("noreply@example.com");
        message.setTo(email);
        message.setSubject("Welcome to our platform!");
        message.setText("Thank you for registering. We are happy to have you.");

        try {
            mailSender.send(message);
        } catch (MailException e) {
            // Co jeÅ›li wysyÅ‚ka siÄ™ nie powiedzie? Logika obsÅ‚ugi bÅ‚Ä™dÃ³w teÅ¼ jest tutaj.
            // Blokuje to rÃ³wnieÅ¼ odpowiedÅº do uÅ¼ytkownika na czas wysyÅ‚ki maila.
            System.err.println("Failed to send email: " + e.getMessage());
        }
    }
}
```

#### Analiza problemu

Ta klasa `UserService` ma **kilka rÃ³Å¼nych odpowiedzialnoÅ›ci**, a co za tym idzie â€“ **kilka powodÃ³w do zmiany**:

1.  **Zmiana reguÅ‚ walidacji:** Analityk biznesowy zmienia wymagania dotyczÄ…ce hasÅ‚a. **Musimy modyfikowaÄ‡ `UserService`**.
2.  **Zmiana sposobu przechowywania danych:** Zmieniamy `UserRepository` na inne ÅºrÃ³dÅ‚o danych. Potencjalnie **musimy modyfikowaÄ‡ `UserService`**.
3.  **Zmiana algorytmu haszowania:** Wprowadzamy Argon2 zamiast BCrypt. **Musimy modyfikowaÄ‡ `UserService`**.
4.  **Zmiana szablonu lub sposobu wysyÅ‚ki e-maili:** DziaÅ‚ marketingu chce dodaÄ‡ HTML do maila, albo przechodzimy na SendGrid API. **Musimy modyfikowaÄ‡ `UserService`**.
5.  **Zmiana polityki obsÅ‚ugi bÅ‚Ä™dÃ³w wysyÅ‚ki:** Co zrobiÄ‡, gdy mail siÄ™ nie wyÅ›le? ZapisaÄ‡ w kolejce? **Musimy modyfikowaÄ‡ `UserService`**.

Klasa jest trudna do testowania (jak testowaÄ‡ logikÄ™ bez prawdziwej bazy i serwera SMTP?), sztywna i podatna na bÅ‚Ä™dy.

---

### Dobry przykÅ‚ad - Zastosowanie zasady SRP w architekturze Spring

Rozbijamy logikÄ™ na wyspecjalizowane komponenty Springa. KaÅ¼dy ma jednÄ…, jasno zdefiniowanÄ… odpowiedzialnoÅ›Ä‡.

#### 1. `RegistrationRequest` (DTO z walidacjÄ…)
OdpowiedzialnoÅ›Ä‡: Przenoszenie danych z warstwy kontrolera i deklarowanie reguÅ‚ walidacji.

```java
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;

public class RegistrationRequest {
    @NotEmpty
    @Email(message = "Invalid email format")
    private String email;

    @NotEmpty
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String password;

    // Getters and Setters
}
```

#### 2. `UserRegistrationController` (Warstwa API)
OdpowiedzialnoÅ›Ä‡: ObsÅ‚uga Å¼Ä…daÅ„ HTTP, walidacja DTO i delegowanie pracy do serwisu.

```java
@RestController
@RequestMapping("/api/users")
public class UserRegistrationController {

    private final RegistrationService registrationService;

    @Autowired
    public UserRegistrationController(RegistrationService registrationService) {
        this.registrationService = registrationService;
    }

    @PostMapping("/register")
    public ResponseEntity<String> registerUser(@Valid @RequestBody RegistrationRequest request) {
        registrationService.register(request.getEmail(), request.getPassword());
        return ResponseEntity.status(HttpStatus.CREATED).body("User registered successfully");
    }
}
```

#### 3. `PasswordEncoder` (Komponent do haszowania)
OdpowiedzialnoÅ›Ä‡: Tylko i wyÅ‚Ä…cznie haszowanie i weryfikacja haseÅ‚. W Springu to standard, konfigurujemy go jako Bean.

```java
// W klasie konfiguracyjnej @Configuration
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

#### 4. `NotificationService` (Serwis powiadomieÅ„)
OdpowiedzialnoÅ›Ä‡: WysyÅ‚anie powiadomieÅ„. MoÅ¼e byÄ‡ asynchroniczny, aby nie blokowaÄ‡ gÅ‚Ã³wnego wÄ…tku.

```java
public interface NotificationService {
    void sendWelcomeEmail(String email);
}

@Service
public class EmailNotificationService implements NotificationService {

    private final JavaMailSender mailSender;

    @Autowired
    public EmailNotificationService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    @Async // Wykonywane asynchronicznie w oddzielnym wÄ…tku
    @Override
    public void sendWelcomeEmail(String email) {
        // ... logika tworzenia i wysyÅ‚ania maila ...
        System.out.println("Sending welcome email to " + email);
        // mailSender.send(...)
    }
}
// PamiÄ™taj o dodaniu @EnableAsync w gÅ‚Ã³wnej klasie aplikacji
```

#### 5. `RegistrationService` (Orkiestrator)
OdpowiedzialnoÅ›Ä‡: **Koordynacja** procesu rejestracji. Nie zawiera logiki walidacji, haszowania, zapisu do bazy czy wysyÅ‚ki maili. Deleguje te zadania do innych komponentÃ³w.

```java
// ğŸ‘ GOOD EXAMPLE - FOLLOWS SRP

@Service
public class RegistrationService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final NotificationService notificationService;

    // ZaleÅ¼noÅ›ci sÄ… wstrzykiwane przez konstruktor
    @Autowired
    public RegistrationService(UserRepository userRepository,
                               PasswordEncoder passwordEncoder,
                               NotificationService notificationService) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.notificationService = notificationService;
    }

    public void register(String email, String rawPassword) {
        // Krok 1: Sprawdzenie logiki biznesowej (delegacja do repozytorium)
        userRepository.findByEmail(email).ifPresent(user -> {
            throw new IllegalStateException("User with this email already exists.");
        });

        // Krok 2: Haszowanie hasÅ‚a (delegacja do PasswordEncoder)
        String hashedPassword = passwordEncoder.encode(rawPassword);

        // Krok 3: Stworzenie obiektu encji
        User user = new User(email, hashedPassword);

        // Krok 4: Zapisanie uÅ¼ytkownika (delegacja do repozytorium)
        userRepository.save(user);

        // Krok 5: WysÅ‚anie powiadomienia (delegacja do serwisu powiadomieÅ„)
        notificationService.sendWelcomeEmail(user.getEmail());
    }
}
```

### Podsumowanie korzyÅ›ci z podejÅ›cia SRP w Springu

1.  **Maksymalna TestowalnoÅ›Ä‡:**
*   MoÅ¼esz testowaÄ‡ `RegistrationService` z uÅ¼yciem mockÃ³w (np. `Mockito`), aby sprawdziÄ‡, czy wywoÅ‚uje odpowiednie metody na repozytorium i serwisie powiadomieÅ„, bez potrzeby uruchamiania bazy danych czy serwera SMTP.
*   MoÅ¼esz osobno testowaÄ‡ logikÄ™ `EmailNotificationService`.

2.  **ElastycznoÅ›Ä‡ i ÅatwoÅ›Ä‡ Zmian:**
*   Chcesz zmieniÄ‡ treÅ›Ä‡ maila lub system wysyÅ‚ki na SMS? Modyfikujesz **tylko** `NotificationService`.
*   Chcesz zmieniÄ‡ algorytm haszowania? Zmieniasz **tylko** konfiguracjÄ™ beana `PasswordEncoder`.
*   Nowe reguÅ‚y walidacji? Dodajesz adnotacje w DTO (`RegistrationRequest`).
*   Klasa `RegistrationService` pozostaje nienaruszona, stabilna i czysta.

3.  **CzytelnoÅ›Ä‡ i SpÃ³jnoÅ›Ä‡:**
*   Kod w `RegistrationService` jest zwiÄ™zÅ‚y i opisuje proces biznesowy na wysokim poziomie abstrakcji. CzytajÄ…c go, od razu wiesz, co siÄ™ dzieje, bez zagÅ‚Ä™biania siÄ™ w szczegÃ³Å‚y implementacyjne.

4.  **Wielokrotne UÅ¼ycie (Reusability):**
*   `NotificationService` moÅ¼e byÄ‡ uÅ¼ywany w innych czÄ™Å›ciach aplikacji, np. do wysyÅ‚ania powiadomieÅ„ o zresetowaniu hasÅ‚a.
*   `PasswordEncoder` jest uÅ¼ywany takÅ¼e przy logowaniu.

Stosowanie SRP w aplikacjach Spring, w poÅ‚Ä…czeniu z wstrzykiwaniem zaleÅ¼noÅ›ci (Dependency Injection), prowadzi do tworzenia solidnych, skalowalnych i Å‚atwych w utrzymaniu systemÃ³w.

## O â€“ Open/Closed Principle

OczywiÅ›cie. WyjaÅ›niÄ™ **ZasadÄ™ Otwarte/ZamkniÄ™te (Open/Closed Principle - OCP)**, korzystajÄ…c z praktycznego, realistycznego przykÅ‚adu w **Javie i frameworku Spring**.

### Wprowadzenie do zasady

**Zasada Otwarte/ZamkniÄ™te** jest jednÄ… z najwaÅ¼niejszych zasad SOLID i gÅ‚osi, Å¼e:

> **Komponenty (klasy, moduÅ‚y, funkcje) powinny byÄ‡ otwarte na rozszerzenia, ale zamkniÄ™te na modyfikacje.**

Co to oznacza w praktyce?
*   **Otwarte na rozszerzenia:** PowinieneÅ› byÄ‡ w stanie dodawaÄ‡ nowe funkcjonalnoÅ›ci lub zachowania do komponentu bez zmieniania jego kodu ÅºrÃ³dÅ‚owego.
*   **ZamkniÄ™te na modyfikacje:** Gdy komponent zostaÅ‚ opracowany i przetestowany, jego kod ÅºrÃ³dÅ‚owy nie powinien byÄ‡ modyfikowany w celu dodania nowej funkcjonalnoÅ›ci. Zmiany powinny dotyczyÄ‡ tylko naprawy bÅ‚Ä™dÃ³w.

GÅ‚Ã³wnym sposobem na osiÄ…gniÄ™cie tego jest uÅ¼ycie **abstrakcji (interfejsÃ³w lub klas abstrakcyjnych)**, co pozwala na tworzenie architektury typu "plug-in".

---

### Scenariusz: System przetwarzania pÅ‚atnoÅ›ci w aplikacji e-commerce

WyobraÅºmy sobie, Å¼e budujemy serwis, ktÃ³ry ma za zadanie przetwarzaÄ‡ pÅ‚atnoÅ›ci za zamÃ³wienia.
*   **PoczÄ…tkowe wymaganie:** System musi obsÅ‚ugiwaÄ‡ pÅ‚atnoÅ›ci kartÄ… kredytowÄ….
*   **PrzyszÅ‚e wymagania:** Biznes planuje w przyszÅ‚oÅ›ci dodaÄ‡ nowe metody pÅ‚atnoÅ›ci, takie jak PayPal, a pÃ³Åºniej rÃ³wnieÅ¼ polski system BLIK.

Naszym celem jest zaprojektowanie systemu tak, aby dodanie nowej metody pÅ‚atnoÅ›ci nie wymagaÅ‚o modyfikacji istniejÄ…cego, dziaÅ‚ajÄ…cego kodu serwisu pÅ‚atnoÅ›ci.

---

### ZÅ‚y przykÅ‚ad - Naruszenie zasady OCP

PodejÅ›cie, ktÃ³re Å‚amie OCP, polega na uÅ¼yciu instrukcji warunkowych (`if-else` lub `switch`) do rozrÃ³Å¼niania metod pÅ‚atnoÅ›ci.

**Kod (po angielsku):**

```java
// ğŸ‘ BAD EXAMPLE - VIOLATES OCP

// Enum do reprezentowania metod pÅ‚atnoÅ›ci
public enum PaymentMethod {
    CREDIT_CARD,
    PAYPAL,
    BLIK
}

@Service
public class PaymentService {

    public void processPayment(BigDecimal amount, PaymentMethod method) {
        // Ten blok if-else jest ZÅAMANIEM ZASADY OCP
        if (method == PaymentMethod.CREDIT_CARD) {
            // Logika specyficzna dla pÅ‚atnoÅ›ci kartÄ…
            System.out.println("Processing credit card payment of: " + amount);
            // ... wywoÅ‚anie API bramek pÅ‚atniczych dla kart ...
        } else if (method == PaymentMethod.PAYPAL) {
            // Logika specyficzna dla PayPal
            System.out.println("Redirecting to PayPal for payment of: " + amount);
            // ... logika przekierowania do PayPal ...
        }
        // ... wiÄ™cej warunkÃ³w w przyszÅ‚oÅ›ci ...
    }
}
```

#### Analiza problemu

Ten kod jest **zamkniÄ™ty na rozszerzenia** i **otwarty na modyfikacje** â€“ dokÅ‚adnie na odwrÃ³t, niÅ¼ mÃ³wi zasada.
1.  **Aby dodaÄ‡ BLIK**, programista musi **zmodyfikowaÄ‡** klasÄ™ `PaymentService`, dodajÄ…c kolejny blok `else if`.
2.  KaÅ¼da taka modyfikacja zwiÄ™ksza zÅ‚oÅ¼onoÅ›Ä‡ klasy i ryzyko wprowadzenia bÅ‚Ä™du (regresji) w juÅ¼ dziaÅ‚ajÄ…cych metodach pÅ‚atnoÅ›ci.
3.  Testowanie staje siÄ™ coraz trudniejsze, poniewaÅ¼ trzeba przetestowaÄ‡ wszystkie gaÅ‚Ä™zie instrukcji warunkowej.
4.  Klasa `PaymentService` zaczyna Å‚amaÄ‡ rÃ³wnieÅ¼ ZasadÄ™ Jednej OdpowiedzialnoÅ›ci (SRP), poniewaÅ¼ wie za duÅ¼o o szczegÃ³Å‚ach implementacyjnych kaÅ¼dej metody pÅ‚atnoÅ›ci.

---

### Dobry przykÅ‚ad - Zastosowanie zasady OCP w architekturze Spring

Aby zaimplementowaÄ‡ OCP, uÅ¼yjemy wzorca projektowego **Strategia (Strategy Pattern)**, ktÃ³ry idealnie komponuje siÄ™ z mechanizmem wstrzykiwania zaleÅ¼noÅ›ci w Springu.

#### 1. Stworzenie Abstrakcji (Kontraktu) - `PaymentProvider`
Definiujemy interfejs, ktÃ³ry bÄ™dzie kontraktem dla wszystkich przyszÅ‚ych metod pÅ‚atnoÅ›ci.

```java
public enum PaymentMethod {
    CREDIT_CARD,
    PAYPAL,
    BLIK
}

public interface PaymentProvider {
    /**
     * Processes the payment.
     */
    void processPayment(BigDecimal amount);

    /**
     * Checks if this provider supports the given payment method.
     */
    boolean supports(PaymentMethod paymentMethod);
}
```

#### 2. Stworzenie Konkretnych Implementacji (RozszerzeÅ„)
Teraz tworzymy osobne klasy dla kaÅ¼dej metody pÅ‚atnoÅ›ci. KaÅ¼da z nich implementuje nasz interfejs `PaymentProvider` i jest oznaczona jako komponent Springa (`@Component`).

```java
// Implementacja dla kart kredytowych
@Component
public class CreditCardPaymentProvider implements PaymentProvider {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Processing credit card payment of: " + amount);
        // ... skomplikowana logika specyficzna dla kart ...
    }

    @Override
    public boolean supports(PaymentMethod paymentMethod) {
        return paymentMethod == PaymentMethod.CREDIT_CARD;
    }
}

// Implementacja dla PayPal
@Component
public class PayPalPaymentProvider implements PaymentProvider {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Redirecting to PayPal for payment of: " + amount);
        // ... skomplikowana logika specyficzna dla PayPal ...
    }

    @Override
    public boolean supports(PaymentMethod paymentMethod) {
        return paymentMethod == PaymentMethod.PAYPAL;
    }
}
```

#### 3. Stworzenie Orkiestratora (Komponent "ZamkniÄ™ty")
`PaymentService` staje siÄ™ teraz "orkiestratorem". Nie wie nic o konkretnych implementacjach. Jego jedynym zadaniem jest znalezienie odpowiedniego dostawcy i delegowanie do niego pracy. **Jego kod nie bÄ™dzie wymagaÅ‚ zmian, gdy dodamy nowÄ… metodÄ™ pÅ‚atnoÅ›ci.**

Wykorzystamy tutaj potÄ™Å¼nÄ… funkcjÄ™ Springa: **wstrzykiwanie wszystkich beanÃ³w danego typu do listy.**

```java
// ğŸ‘ GOOD EXAMPLE - FOLLOWS OCP

@Service
public class PaymentService {

    private final List<PaymentProvider> paymentProviders;

    // Spring automatycznie wstrzyknie listÄ™ wszystkich beanÃ³w,
    // ktÃ³re implementujÄ… interfejs PaymentProvider.
    @Autowired
    public PaymentService(List<PaymentProvider> paymentProviders) {
        this.paymentProviders = paymentProviders;
    }

    public void processPayment(BigDecimal amount, PaymentMethod method) {
        // ZnajdÅº odpowiedniego dostawcÄ™ bez uÅ¼ycia if-else
        PaymentProvider provider = paymentProviders.stream()
                .filter(p -> p.supports(method))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Unsupported payment method: " + method));

        // Deleguj wykonanie pÅ‚atnoÅ›ci
        provider.processPayment(amount);
    }
}
```

#### Jak teraz dodaÄ‡ nowÄ… metodÄ™ pÅ‚atnoÅ›ci (np. BLIK)?

Wystarczy stworzyÄ‡ **nowÄ… klasÄ™**. Nie dotykamy `PaymentService` ani Å¼adnej innej istniejÄ…cej klasy!

```java
// Nowe rozszerzenie - dodane bez modyfikacji istniejÄ…cego kodu!
@Component
public class BlikPaymentProvider implements PaymentProvider {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Generating BLIK code for payment of: " + amount);
        // ... logika specyficzna dla BLIK ...
    }

    @Override
    public boolean supports(PaymentMethod paymentMethod) {
        return paymentMethod == PaymentMethod.BLIK;
    }
}
```

Gdy aplikacja Springa uruchomi siÄ™ ponownie, automatycznie wykryje nowy bean `BlikPaymentProvider`, doda go do listy w `PaymentService` i system od razu zacznie obsÅ‚ugiwaÄ‡ pÅ‚atnoÅ›ci BLIK.

### Podsumowanie korzyÅ›ci z podejÅ›cia OCP

1.  **ElastycznoÅ›Ä‡ i skalowalnoÅ›Ä‡:** System jest "otwarty na rozszerzenia". Nowe funkcjonalnoÅ›ci sÄ… dodawane poprzez tworzenie nowych klas, a nie modyfikacjÄ™ starych. To architektura typu "plug-and-play".
2.  **StabilnoÅ›Ä‡ i mniejsze ryzyko:** System jest "zamkniÄ™ty na modyfikacje". GÅ‚Ã³wna logika biznesowa w `PaymentService` jest stabilna, przetestowana i nie jest naraÅ¼ona na bÅ‚Ä™dy regresji przy dodawaniu nowych opcji.
3.  **ÅatwoÅ›Ä‡ utrzymania i testowania:** KaÅ¼dÄ… metodÄ™ pÅ‚atnoÅ›ci (`PaymentProvider`) moÅ¼na rozwijaÄ‡ i testowaÄ‡ niezaleÅ¼nie. Testowanie `PaymentService` jest proste â€“ wystarczy dostarczyÄ‡ mu listÄ™ zamockowanych dostawcÃ³w.
4.  **ZgodnoÅ›Ä‡ z innymi zasadami SOLID:**
*   **SRP:** KaÅ¼dy `PaymentProvider` ma jednÄ…, dobrze zdefiniowanÄ… odpowiedzialnoÅ›Ä‡.
*   **DIP:** `PaymentService` zaleÅ¼y od abstrakcji (`PaymentProvider`), a nie od konkretnych implementacji.

Zastosowanie OCP prowadzi do tworzenia czystych, moduÅ‚owych i elastycznych systemÃ³w, ktÃ³re Å‚atwo adaptujÄ… siÄ™ do zmieniajÄ…cych siÄ™ wymagaÅ„ biznesowych.


## L â€“ Liskov Substitution Principle

OczywiÅ›cie. WyjaÅ›niÄ™ **ZasadÄ™ Otwarte/ZamkniÄ™te (Open/Closed Principle - OCP)**, korzystajÄ…c z praktycznego, realistycznego przykÅ‚adu w **Javie i frameworku Spring**.

### Wprowadzenie do zasady

**Zasada Otwarte/ZamkniÄ™te** jest jednÄ… z najwaÅ¼niejszych zasad SOLID i gÅ‚osi, Å¼e:

> **Komponenty (klasy, moduÅ‚y, funkcje) powinny byÄ‡ otwarte na rozszerzenia, ale zamkniÄ™te na modyfikacje.**

Co to oznacza w praktyce?
*   **Otwarte na rozszerzenia:** PowinieneÅ› byÄ‡ w stanie dodawaÄ‡ nowe funkcjonalnoÅ›ci lub zachowania do komponentu bez zmieniania jego kodu ÅºrÃ³dÅ‚owego.
*   **ZamkniÄ™te na modyfikacje:** Gdy komponent zostaÅ‚ opracowany i przetestowany, jego kod ÅºrÃ³dÅ‚owy nie powinien byÄ‡ modyfikowany w celu dodania nowej funkcjonalnoÅ›ci. Zmiany powinny dotyczyÄ‡ tylko naprawy bÅ‚Ä™dÃ³w.

GÅ‚Ã³wnym sposobem na osiÄ…gniÄ™cie tego jest uÅ¼ycie **abstrakcji (interfejsÃ³w lub klas abstrakcyjnych)**, co pozwala na tworzenie architektury typu "plug-in".

---

### Scenariusz: System przetwarzania pÅ‚atnoÅ›ci w aplikacji e-commerce

WyobraÅºmy sobie, Å¼e budujemy serwis, ktÃ³ry ma za zadanie przetwarzaÄ‡ pÅ‚atnoÅ›ci za zamÃ³wienia.
*   **PoczÄ…tkowe wymaganie:** System musi obsÅ‚ugiwaÄ‡ pÅ‚atnoÅ›ci kartÄ… kredytowÄ….
*   **PrzyszÅ‚e wymagania:** Biznes planuje w przyszÅ‚oÅ›ci dodaÄ‡ nowe metody pÅ‚atnoÅ›ci, takie jak PayPal, a pÃ³Åºniej rÃ³wnieÅ¼ polski system BLIK.

Naszym celem jest zaprojektowanie systemu tak, aby dodanie nowej metody pÅ‚atnoÅ›ci nie wymagaÅ‚o modyfikacji istniejÄ…cego, dziaÅ‚ajÄ…cego kodu serwisu pÅ‚atnoÅ›ci.

---

### ZÅ‚y przykÅ‚ad - Naruszenie zasady OCP

PodejÅ›cie, ktÃ³re Å‚amie OCP, polega na uÅ¼yciu instrukcji warunkowych (`if-else` lub `switch`) do rozrÃ³Å¼niania metod pÅ‚atnoÅ›ci.

**Kod (po angielsku):**

```java
// ğŸ‘ BAD EXAMPLE - VIOLATES OCP

// Enum do reprezentowania metod pÅ‚atnoÅ›ci
public enum PaymentMethod {
    CREDIT_CARD,
    PAYPAL,
    BLIK
}

@Service
public class PaymentService {

    public void processPayment(BigDecimal amount, PaymentMethod method) {
        // Ten blok if-else jest ZÅAMANIEM ZASADY OCP
        if (method == PaymentMethod.CREDIT_CARD) {
            // Logika specyficzna dla pÅ‚atnoÅ›ci kartÄ…
            System.out.println("Processing credit card payment of: " + amount);
            // ... wywoÅ‚anie API bramek pÅ‚atniczych dla kart ...
        } else if (method == PaymentMethod.PAYPAL) {
            // Logika specyficzna dla PayPal
            System.out.println("Redirecting to PayPal for payment of: " + amount);
            // ... logika przekierowania do PayPal ...
        }
        // ... wiÄ™cej warunkÃ³w w przyszÅ‚oÅ›ci ...
    }
}
```

#### Analiza problemu

Ten kod jest **zamkniÄ™ty na rozszerzenia** i **otwarty na modyfikacje** â€“ dokÅ‚adnie na odwrÃ³t, niÅ¼ mÃ³wi zasada.
1.  **Aby dodaÄ‡ BLIK**, programista musi **zmodyfikowaÄ‡** klasÄ™ `PaymentService`, dodajÄ…c kolejny blok `else if`.
2.  KaÅ¼da taka modyfikacja zwiÄ™ksza zÅ‚oÅ¼onoÅ›Ä‡ klasy i ryzyko wprowadzenia bÅ‚Ä™du (regresji) w juÅ¼ dziaÅ‚ajÄ…cych metodach pÅ‚atnoÅ›ci.
3.  Testowanie staje siÄ™ coraz trudniejsze, poniewaÅ¼ trzeba przetestowaÄ‡ wszystkie gaÅ‚Ä™zie instrukcji warunkowej.
4.  Klasa `PaymentService` zaczyna Å‚amaÄ‡ rÃ³wnieÅ¼ ZasadÄ™ Jednej OdpowiedzialnoÅ›ci (SRP), poniewaÅ¼ wie za duÅ¼o o szczegÃ³Å‚ach implementacyjnych kaÅ¼dej metody pÅ‚atnoÅ›ci.

---

### Dobry przykÅ‚ad - Zastosowanie zasady OCP w architekturze Spring

Aby zaimplementowaÄ‡ OCP, uÅ¼yjemy wzorca projektowego **Strategia (Strategy Pattern)**, ktÃ³ry idealnie komponuje siÄ™ z mechanizmem wstrzykiwania zaleÅ¼noÅ›ci w Springu.

#### 1. Stworzenie Abstrakcji (Kontraktu) - `PaymentProvider`
Definiujemy interfejs, ktÃ³ry bÄ™dzie kontraktem dla wszystkich przyszÅ‚ych metod pÅ‚atnoÅ›ci.

```java
public enum PaymentMethod {
    CREDIT_CARD,
    PAYPAL,
    BLIK
}

public interface PaymentProvider {
    /**
     * Processes the payment.
     */
    void processPayment(BigDecimal amount);

    /**
     * Checks if this provider supports the given payment method.
     */
    boolean supports(PaymentMethod paymentMethod);
}
```

#### 2. Stworzenie Konkretnych Implementacji (RozszerzeÅ„)
Teraz tworzymy osobne klasy dla kaÅ¼dej metody pÅ‚atnoÅ›ci. KaÅ¼da z nich implementuje nasz interfejs `PaymentProvider` i jest oznaczona jako komponent Springa (`@Component`).

```java
// Implementacja dla kart kredytowych
@Component
public class CreditCardPaymentProvider implements PaymentProvider {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Processing credit card payment of: " + amount);
        // ... skomplikowana logika specyficzna dla kart ...
    }

    @Override
    public boolean supports(PaymentMethod paymentMethod) {
        return paymentMethod == PaymentMethod.CREDIT_CARD;
    }
}

// Implementacja dla PayPal
@Component
public class PayPalPaymentProvider implements PaymentProvider {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Redirecting to PayPal for payment of: " + amount);
        // ... skomplikowana logika specyficzna dla PayPal ...
    }

    @Override
    public boolean supports(PaymentMethod paymentMethod) {
        return paymentMethod == PaymentMethod.PAYPAL;
    }
}
```

#### 3. Stworzenie Orkiestratora (Komponent "ZamkniÄ™ty")
`PaymentService` staje siÄ™ teraz "orkiestratorem". Nie wie nic o konkretnych implementacjach. Jego jedynym zadaniem jest znalezienie odpowiedniego dostawcy i delegowanie do niego pracy. **Jego kod nie bÄ™dzie wymagaÅ‚ zmian, gdy dodamy nowÄ… metodÄ™ pÅ‚atnoÅ›ci.**

Wykorzystamy tutaj potÄ™Å¼nÄ… funkcjÄ™ Springa: **wstrzykiwanie wszystkich beanÃ³w danego typu do listy.**

```java
// ğŸ‘ GOOD EXAMPLE - FOLLOWS OCP

@Service
public class PaymentService {

    private final List<PaymentProvider> paymentProviders;

    // Spring automatycznie wstrzyknie listÄ™ wszystkich beanÃ³w,
    // ktÃ³re implementujÄ… interfejs PaymentProvider.
    @Autowired
    public PaymentService(List<PaymentProvider> paymentProviders) {
        this.paymentProviders = paymentProviders;
    }

    public void processPayment(BigDecimal amount, PaymentMethod method) {
        // ZnajdÅº odpowiedniego dostawcÄ™ bez uÅ¼ycia if-else
        PaymentProvider provider = paymentProviders.stream()
                .filter(p -> p.supports(method))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Unsupported payment method: " + method));

        // Deleguj wykonanie pÅ‚atnoÅ›ci
        provider.processPayment(amount);
    }
}
```

#### Jak teraz dodaÄ‡ nowÄ… metodÄ™ pÅ‚atnoÅ›ci (np. BLIK)?

Wystarczy stworzyÄ‡ **nowÄ… klasÄ™**. Nie dotykamy `PaymentService` ani Å¼adnej innej istniejÄ…cej klasy!

```java
// Nowe rozszerzenie - dodane bez modyfikacji istniejÄ…cego kodu!
@Component
public class BlikPaymentProvider implements PaymentProvider {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Generating BLIK code for payment of: " + amount);
        // ... logika specyficzna dla BLIK ...
    }

    @Override
    public boolean supports(PaymentMethod paymentMethod) {
        return paymentMethod == PaymentMethod.BLIK;
    }
}
```

Gdy aplikacja Springa uruchomi siÄ™ ponownie, automatycznie wykryje nowy bean `BlikPaymentProvider`, doda go do listy w `PaymentService` i system od razu zacznie obsÅ‚ugiwaÄ‡ pÅ‚atnoÅ›ci BLIK.

### Podsumowanie korzyÅ›ci z podejÅ›cia OCP

1.  **ElastycznoÅ›Ä‡ i skalowalnoÅ›Ä‡:** System jest "otwarty na rozszerzenia". Nowe funkcjonalnoÅ›ci sÄ… dodawane poprzez tworzenie nowych klas, a nie modyfikacjÄ™ starych. To architektura typu "plug-and-play".
2.  **StabilnoÅ›Ä‡ i mniejsze ryzyko:** System jest "zamkniÄ™ty na modyfikacje". GÅ‚Ã³wna logika biznesowa w `PaymentService` jest stabilna, przetestowana i nie jest naraÅ¼ona na bÅ‚Ä™dy regresji przy dodawaniu nowych opcji.
3.  **ÅatwoÅ›Ä‡ utrzymania i testowania:** KaÅ¼dÄ… metodÄ™ pÅ‚atnoÅ›ci (`PaymentProvider`) moÅ¼na rozwijaÄ‡ i testowaÄ‡ niezaleÅ¼nie. Testowanie `PaymentService` jest proste â€“ wystarczy dostarczyÄ‡ mu listÄ™ zamockowanych dostawcÃ³w.
4.  **ZgodnoÅ›Ä‡ z innymi zasadami SOLID:**
*   **SRP:** KaÅ¼dy `PaymentProvider` ma jednÄ…, dobrze zdefiniowanÄ… odpowiedzialnoÅ›Ä‡.
*   **DIP:** `PaymentService` zaleÅ¼y od abstrakcji (`PaymentProvider`), a nie od konkretnych implementacji.

Zastosowanie OCP prowadzi do tworzenia czystych, moduÅ‚owych i elastycznych systemÃ³w, ktÃ³re Å‚atwo adaptujÄ… siÄ™ do zmieniajÄ…cych siÄ™ wymagaÅ„ biznesowych.


## I â€“ Interface Segregation Principle

OczywiÅ›cie, przejdÅºmy do **Zasady Segregacji InterfejsÃ³w (Interface Segregation Principle - ISP)**, ilustrujÄ…c jÄ… praktycznym przykÅ‚adem w Javie i Springu.

### Wprowadzenie do zasady

**Zasada Segregacji InterfejsÃ³w** jest jednÄ… z najprostszych do zrozumienia zasad SOLID. MÃ³wi ona, Å¼e:

> **Klienci (klasy) nie powinni byÄ‡ zmuszani do implementowania interfejsÃ³w, ktÃ³rych metod nie uÅ¼ywajÄ….**

Innymi sÅ‚owy, lepiej jest mieÄ‡ wiele maÅ‚ych, specyficznych interfejsÃ³w niÅ¼ jeden duÅ¼y, ogÃ³lny ("gruby" interfejs). Kiedy klasa implementuje interfejs, powinna wykorzystywaÄ‡ wszystkie jego metody. JeÅ›li jest zmuszona do implementowania metod, ktÃ³re w jej kontekÅ›cie nie majÄ… sensu (np. poprzez rzucanie `UnsupportedOperationException` lub pozostawianie pustej implementacji), jest to sygnaÅ‚ naruszenia ISP.

---

### Scenariusz: ZarzÄ…dzanie dokumentami w systemie firmowym

WyobraÅºmy sobie system, w ktÃ³rym zarzÄ…dzamy rÃ³Å¼nymi typami dokumentÃ³w. Mamy dokumenty, ktÃ³re sÄ… przechowywane w bazie danych, a takÅ¼e dokumenty, ktÃ³re sÄ… generowane w locie i mogÄ… byÄ‡ drukowane lub eksportowane do formatu PDF.

Chcemy stworzyÄ‡ jednolity mechanizm do operacji na dokumentach.

---

### ZÅ‚y przykÅ‚ad - Naruszenie zasady ISP ("Gruby" interfejs)

PoczÄ…tkowe podejÅ›cie moÅ¼e polegaÄ‡ na stworzeniu jednego, duÅ¼ego interfejsu, ktÃ³ry obejmuje wszystkie moÅ¼liwe operacje.

**Kod (po angielsku):**

```java
// ğŸ‘ BAD EXAMPLE - "FAT" INTERFACE VIOLATING ISP

public interface DocumentOperations {

    // Metody zwiÄ…zane z trwaÅ‚oÅ›ciÄ… (bazÄ… danych)
    void save(Document d);
    Document findById(long id);
    void delete(long id);

    // Metody zwiÄ…zane z konwersjÄ… i wydrukiem
    byte[] toPdf(Document d);
    void print(Document d);
}
```

Teraz sprÃ³bujmy zaimplementowaÄ‡ ten interfejs dla rÃ³Å¼nych typÃ³w dokumentÃ³w.

**Implementacja dla dokumentu trwaÅ‚ego (np. faktury):**
Faktura jest przechowywana w bazie, moÅ¼e byÄ‡ drukowana i eksportowana. WyglÄ…da to w miarÄ™ OK.

```java
@Component
public class InvoiceDocumentManager implements DocumentOperations {

    @Override
    public void save(Document d) { /* ... logika zapisu do DB ... */ }

    @Override
    public Document findById(long id) { /* ... logika odczytu z DB ... */ return null; }

    @Override
    public void delete(long id) { /* ... logika usuniÄ™cia z DB ... */ }

    @Override
    public byte[] toPdf(Document d) { /* ... logika generowania PDF ... */ return new byte[0]; }

    @Override
    public void print(Document d) { /* ... logika wysÅ‚ania do drukarki ... */ }
}
```

**Implementacja dla dokumentu generowanego w locie (np. raportu tymczasowego):**
Raport tymczasowy nie jest zapisywany w bazie danych. Jest tworzony, eksportowany do PDF, a nastÄ™pnie znika. Tutaj pojawia siÄ™ problem:

```java
@Component
public class TemporaryReportManager implements DocumentOperations {

    // Te metody nie majÄ… sensu dla raportu tymczasowego.
    // JesteÅ›my zmuszeni do ich zaimplementowania.
    @Override
    public void save(Document d) {
        throw new UnsupportedOperationException("Temporary reports cannot be saved.");
    }

    @Override
    public Document findById(long id) {
        throw new UnsupportedOperationException("Temporary reports cannot be found by ID.");
    }

    @Override
    public void delete(long id) {
        // Co tu zrobiÄ‡? ZostawiÄ‡ puste? To teÅ¼ jest mylÄ…ce.
    }

    // Te metody sÄ… uÅ¼ywane
    @Override
    public byte[] toPdf(Document d) {
        System.out.println("Generating PDF for a temporary report.");
        // ... logika generowania PDF ...
        return new byte[0];
    }

    @Override
    public void print(Document d) {
        System.out.println("Printing a temporary report.");
        // ... logika wysÅ‚ania do drukarki ...
    }
}
```

#### Analiza problemu

1.  **Wymuszona implementacja:** Klasa `TemporaryReportManager` jest zmuszona do implementowania metod `save`, `findById`, `delete`, mimo Å¼e ich nie potrzebuje. To prowadzi do nieczystego kodu (puste metody, rzucanie wyjÄ…tkÃ³w), ktÃ³ry jest trudny w utrzymaniu i mylÄ…cy dla innych programistÃ³w.
2.  **KruchoÅ›Ä‡ i niejasny kontrakt:** Klient, ktÃ³ry otrzymuje obiekt typu `DocumentOperations`, nie wie, czy moÅ¼e bezpiecznie wywoÅ‚aÄ‡ na nim metodÄ™ `save()`. MusiaÅ‚by uÅ¼yÄ‡ `instanceof`, aby sprawdziÄ‡, z jakÄ… konkretnie implementacjÄ… ma do czynienia, co Å‚amie rÃ³wnieÅ¼ zasadÄ™ Liskov.
3.  **Niepotrzebne zaleÅ¼noÅ›ci:** JeÅ›li klient potrzebuje tylko konwertowaÄ‡ dokument do PDF, wciÄ…Å¼ musi mieÄ‡ zaleÅ¼noÅ›Ä‡ do caÅ‚ego "grubego" interfejsu, wÅ‚Ä…czajÄ…c w to metody, ktÃ³rych nigdy nie uÅ¼yje.

---

### Dobry przykÅ‚ad - Zastosowanie zasady ISP (Segregacja interfejsÃ³w)

RozwiÄ…zaniem jest podzielenie "grubego" interfejsu na mniejsze, bardziej spÃ³jne interfejsy, kaÅ¼dy z nich skupiony na jednej, konkretnej odpowiedzialnoÅ›ci.

```java
// ğŸ‘ GOOD EXAMPLE - SEGREGATED INTERFACES

// Interfejs dla operacji na trwaÅ‚ych danych (CRUD)
public interface PersistentDocumentStore {
    void save(Document d);
    Document findById(long id);
    void delete(long id);
}

// Interfejs dla operacji konwersji
public interface ConvertibleDocument {
    byte[] toPdf(Document d);
}

// Interfejs dla operacji wydruku
public interface PrintableDocument {
    void print(Document d);
}
```

Teraz nasze klasy implementujÄ… tylko te interfejsy, ktÃ³rych funkcjonalnoÅ›ci rzeczywiÅ›cie dostarczajÄ….

**Implementacja dla `InvoiceDocumentManager`:**
Faktura moÅ¼e byÄ‡ przechowywana, konwertowana i drukowana, wiÄ™c implementuje wszystkie trzy interfejsy.

```java
@Component
public class InvoiceDocumentManager implements PersistentDocumentStore, ConvertibleDocument, PrintableDocument {
    @Override
    public void save(Document d) { /* ... */ }

    @Override
    public Document findById(long id) { /* ... */ return null; }

    @Override
    public void delete(long id) { /* ... */ }

    @Override
    public byte[] toPdf(Document d) { /* ... */ return new byte[0]; }

    @Override
    public void print(Document d) { /* ... */ }
}
```

**Implementacja dla `TemporaryReportManager`:**
Raport tymczasowy moÅ¼e byÄ‡ tylko konwertowany i drukowany.

```java
@Component
public class TemporaryReportManager implements ConvertibleDocument, PrintableDocument {

    // Implementuje tylko te metody, ktÃ³re majÄ… sens.
    @Override
    public byte[] toPdf(Document d) {
        System.out.println("Generating PDF for a temporary report.");
        return new byte[0];
    }

    @Override
    public void print(Document d) {
        System.out.println("Printing a temporary report.");
    }
}
```

#### Jak to wyglÄ…da po stronie klienta (np. serwisu Springa)?

Klient (serwis) deklaruje zaleÅ¼noÅ›Ä‡ tylko od tych interfejsÃ³w, ktÃ³rych potrzebuje do wykonania swojego zadania.

```java
@Service
public class DocumentProcessingService {

    private final ConvertibleDocument pdfConverter;
    private final PersistentDocumentStore documentStore;

    @Autowired
    public DocumentProcessingService(
        // Wstrzykujemy konkretnÄ… implementacjÄ™, np. TemporaryReportManager
        @Qualifier("temporaryReportManager") ConvertibleDocument pdfConverter,
        // Wstrzykujemy innÄ… implementacjÄ™, np. InvoiceDocumentManager
        @Qualifier("invoiceDocumentManager") PersistentDocumentStore documentStore) {
        this.pdfConverter = pdfConverter;
        this.documentStore = documentStore;
    }

    // Ta metoda potrzebuje tylko moÅ¼liwoÅ›ci konwersji do PDF
    public byte[] generatePdfReport(Document reportData) {
        // Wie, Å¼e pdfConverter na pewno ma metodÄ™ toPdf()
        return pdfConverter.toPdf(reportData);
    }

    // Ta metoda potrzebuje tylko moÅ¼liwoÅ›ci zapisu do bazy
    public void archiveDocument(Document docToArchive) {
        // Wie, Å¼e documentStore na pewno ma metodÄ™ save()
        documentStore.save(docToArchive);
    }
}
```
DziÄ™ki `@Qualifier` Spring wie, ktÃ³rÄ… implementacjÄ™ danego interfejsu ma wstrzyknÄ…Ä‡, jeÅ›li istnieje wiÄ™cej niÅ¼ jedna.

### Podsumowanie korzyÅ›ci z podejÅ›cia ISP

1.  **SpÃ³jnoÅ›Ä‡ i Czysty Kod:** Klasy implementujÄ… tylko te metody, ktÃ³re sÄ… dla nich istotne. Unikamy pustych implementacji i wyjÄ…tkÃ³w `UnsupportedOperationException`.
2.  **Jasne Kontrakty:** Kiedy klient zaleÅ¼y od maÅ‚ego interfejsu (np. `PrintableDocument`), ma 100% pewnoÅ›ci, Å¼e kaÅ¼dy obiekt, ktÃ³ry otrzyma, bÄ™dzie w stanie wykonaÄ‡ operacjÄ™ `print()`.
3.  **Lepsza ElastycznoÅ›Ä‡ i Mniejsze PowiÄ…zania (Loose Coupling):** Klient zaleÅ¼y tylko od tego, czego potrzebuje. Zmiany w interfejsie `PersistentDocumentStore` nie wpÅ‚ynÄ… na klienta, ktÃ³ry uÅ¼ywa tylko `ConvertibleDocument`.
4.  **ÅatwoÅ›Ä‡ Utrzymania i Testowania:** MaÅ‚e interfejsy sÄ… Å‚atwiejsze do zrozumienia, implementacji i mockowania w testach jednostkowych.

Zasada Segregacji InterfejsÃ³w zachÄ™ca do myÅ›lenia o rolach i odpowiedzialnoÅ›ciach nie tylko na poziomie klas, ale takÅ¼e na poziomie ich "publicznych kontraktÃ³w", czyli interfejsÃ³w.

## D â€“ Dependency Inversion Principle

OczywiÅ›cie. PrzejdÅºmy do ostatniej, ale niezwykle waÅ¼nej zasady â€“ **Zasady OdwrÃ³cenia ZaleÅ¼noÅ›ci (Dependency Inversion Principle - DIP)**. PokaÅ¼Ä™ jÄ… na przykÅ‚adzie w Javie i Springu, poniewaÅ¼ ten framework jest w duÅ¼ej mierze zbudowany wokÃ³Å‚ tej zasady.

### Wprowadzenie do zasady

**Zasada OdwrÃ³cenia ZaleÅ¼noÅ›ci** skÅ‚ada siÄ™ z dwÃ³ch kluczowych stwierdzeÅ„:

1.  **ModuÅ‚y wysokiego poziomu nie powinny zaleÅ¼eÄ‡ od moduÅ‚Ã³w niskiego poziomu. Oba powinny zaleÅ¼eÄ‡ od abstrakcji (np. interfejsÃ³w).**
2.  **Abstrakcje nie powinny zaleÅ¼eÄ‡ od szczegÃ³Å‚Ã³w. To szczegÃ³Å‚y (konkretne implementacje) powinny zaleÅ¼eÄ‡ od abstrakcji.**

Co to oznacza w praktyce?
*   **ModuÅ‚ wysokiego poziomu:** Kod, ktÃ³ry zawiera gÅ‚Ã³wnÄ… logikÄ™ biznesowÄ…, np. serwis przetwarzajÄ…cy zamÃ³wienie.
*   **ModuÅ‚ niskiego poziomu:** Kod, ktÃ³ry zajmuje siÄ™ technicznymi detalami, np. zapis do konkretnej bazy danych (MySQL), wysyÅ‚ka maila przez konkretnego dostawcÄ™ (Gmail SMTP).
*   **"OdwrÃ³cenie zaleÅ¼noÅ›ci":** Zamiast sytuacji, w ktÃ³rej `LogikaBiznesowa -> KonkretnaBazaDanych`, tworzymy sytuacjÄ™, w ktÃ³rej `LogikaBiznesowa -> InterfejsBazyDanych <- KonkretnaBazaDanych`. Kierunek zaleÅ¼noÅ›ci zostaÅ‚ "odwrÃ³cony" od konkretnej implementacji w stronÄ™ abstrakcji.

GÅ‚Ã³wnym narzÄ™dziem do implementacji DIP jest **Wstrzykiwanie ZaleÅ¼noÅ›ci (Dependency Injection - DI)**, ktÃ³re jest sercem frameworka Spring.

---

### Scenariusz: Serwis do generowania raportÃ³w

WyobraÅºmy sobie serwis, ktÃ³rego zadaniem jest generowanie raportu sprzedaÅ¼y.
1.  **ModuÅ‚ wysokiego poziomu:** `ReportService` â€“ jego zadaniem jest pobranie danych sprzedaÅ¼owych, przetworzenie ich i wygenerowanie raportu.
2.  **ModuÅ‚y niskiego poziomu:**
*   `MySqlSalesRepository` â€“ moduÅ‚ odpowiedzialny za pobieranie danych o sprzedaÅ¼y z bazy danych MySQL.
*   `PdfReportGenerator` â€“ moduÅ‚ odpowiedzialny za formatowanie danych i tworzenie pliku PDF.

---

### ZÅ‚y przykÅ‚ad - Naruszenie zasady DIP

W podejÅ›ciu Å‚amiÄ…cym DIP, moduÅ‚ wysokiego poziomu bezpoÅ›rednio tworzy i zaleÅ¼y od moduÅ‚Ã³w niskiego poziomu.

**Kod (po angielsku):**

```java
// ğŸ‘ BAD EXAMPLE - VIOLATES DIP

// ------ ModuÅ‚y niskiego poziomu (szczegÃ³Å‚y implementacyjne) ------
class MySqlSalesRepository {
    public List<SaleData> fetchSalesData(LocalDate from, LocalDate to) {
        System.out.println("Fetching data from MySQL database...");
        // ... logika SQL ...
        return List.of(new SaleData(), new SaleData());
    }
}

class PdfReportGenerator {
    public byte[] generate(List<SaleData> data) {
        System.out.println("Generating PDF report...");
        // ... logika tworzenia PDF za pomocÄ… biblioteki iText/PDFBox ...
        return new byte[1024];
    }
}


// ------ ModuÅ‚ wysokiego poziomu (logika biznesowa) ------
@Service
public class ReportService {

    // BEZPOÅšREDNIA, SZTYWNA ZALEÅ»NOÅšÄ† OD KONKRETNYCH KLAS
    private final MySqlSalesRepository repository;
    private final PdfReportGenerator generator;

    public ReportService() {
        // Serwis SAM tworzy swoje zaleÅ¼noÅ›ci. To jest "zapach kodu".
        this.repository = new MySqlSalesRepository();
        this.generator = new PdfReportGenerator();
    }

    public byte[] generateSalesReport(LocalDate from, LocalDate to) {
        // Logika biznesowa jest Å›ciÅ›le powiÄ…zana z implementacjÄ…
        List<SaleData> salesData = repository.fetchSalesData(from, to);
        // ... jakaÅ› dodatkowa logika, np. obliczanie sum ...
        byte[] report = generator.generate(salesData);
        return report;
    }
}
```

#### Analiza problemu

1.  **Sztywne powiÄ…zania (Tight Coupling):** `ReportService` jest "przyklejony" do `MySqlSalesRepository` i `PdfReportGenerator`.
*   Co jeÅ›li chcemy zmieniÄ‡ bazÄ™ danych na PostgreSQL? Musimy **zmodyfikowaÄ‡ kod `ReportService`**.
*   Co jeÅ›li chcemy generowaÄ‡ raporty w formacie CSV zamiast PDF? Musimy **zmodyfikowaÄ‡ kod `ReportService`**.
2.  **NietestowalnoÅ›Ä‡:** Jak przetestowaÄ‡ `ReportService` w izolacji? To prawie niemoÅ¼liwe. KaÅ¼dy test `ReportService` bÄ™dzie rÃ³wnieÅ¼ testem `MySqlSalesRepository`, co wymaga dziaÅ‚ajÄ…cej bazy danych MySQL. Nie moÅ¼emy Å‚atwo "podmieniÄ‡" repozytorium na testowÄ… atrapÄ™ (mock).
3.  **Åamanie OCP:** System jest zamkniÄ™ty na rozszerzenia. Dodanie nowej opcji (np. raport CSV) wymaga modyfikacji istniejÄ…cej klasy.

---

### Dobry przykÅ‚ad - Zastosowanie zasady DIP z pomocÄ… Springa

Teraz "odwrÃ³cimy" zaleÅ¼noÅ›ci. Logika biznesowa bÄ™dzie zaleÅ¼eÄ‡ od abstrakcji, a nie od konkretÃ³w.

#### 1. Zdefiniowanie Abstrakcji (InterfejsÃ³w)
Najpierw tworzymy interfejsy, ktÃ³re opisujÄ…, **CO** majÄ… robiÄ‡ moduÅ‚y niskiego poziomu, a nie **JAK**. To sÄ… nasze kontrakty.

```java
// Kontrakt dla repozytorium danych
public interface SalesRepository {
    List<SaleData> fetchSalesData(LocalDate from, LocalDate to);
}

// Kontrakt dla generatora raportÃ³w
public interface ReportGenerator {
    byte[] generate(List<SaleData> data);
    ReportFormat supports();
}

public enum ReportFormat {
    PDF, CSV
}
```

#### 2. Stworzenie Konkretnych Implementacji (SzczegÃ³Å‚Ã³w)
Teraz tworzymy konkretne klasy, ktÃ³re implementujÄ… nasze interfejsy. SÄ… one oznaczone jako komponenty Springa.

```java
// Implementacja dla MySQL
@Repository("mysqlSalesRepository") // Nadajemy nazwÄ™, aby uniknÄ…Ä‡ konfliktÃ³w
public class MySqlSalesRepository implements SalesRepository {
    @Override
    public List<SaleData> fetchSalesData(LocalDate from, LocalDate to) {
        System.out.println("Fetching data from MySQL database...");
        return List.of(new SaleData());
    }
}

// Implementacja dla PostgreSQL (moÅ¼emy jÄ… dodaÄ‡ w przyszÅ‚oÅ›ci)
@Repository("postgresSalesRepository")
public class PostgresSalesRepository implements SalesRepository {
    @Override
    public List<SaleData> fetchSalesData(LocalDate from, LocalDate to) {
        System.out.println("Fetching data from PostgreSQL database...");
        return List.of(new SaleData());
    }
}

// Implementacja dla PDF
@Component
public class PdfReportGenerator implements ReportGenerator {
    @Override
    public byte[] generate(List<SaleData> data) {
        System.out.println("Generating PDF report...");
        return new byte[0];
    }
    @Override
    public ReportFormat supports() { return ReportFormat.PDF; }
}
```

#### 3. Zmodyfikowanie ModuÅ‚u Wysokiego Poziomu
`ReportService` zaleÅ¼y teraz tylko od abstrakcji. Nie wie nic o MySQL ani o PDF. ZaleÅ¼noÅ›ci sÄ… mu "wstrzykiwane" z zewnÄ…trz przez Springa.

```java
// ğŸ‘ GOOD EXAMPLE - FOLLOWS DIP

@Service
public class ReportService {

    // ZaleÅ¼noÅ›Ä‡ od ABSTRAKCJI, a nie od konkretnej klasy
    private final SalesRepository repository;
    private final List<ReportGenerator> generators; // Wstrzykujemy listÄ™ wszystkich generatorÃ³w

    // ZaleÅ¼noÅ›ci sÄ… WSTRZYKIWANE przez konstruktor - to jest Dependency Injection
    @Autowired
    public ReportService(
        @Qualifier("mysqlSalesRepository") SalesRepository repository, // Wybieramy implementacjÄ™
        List<ReportGenerator> generators) {
        this.repository = repository;
        this.generators = generators;
    }

    public byte[] generateSalesReport(LocalDate from, LocalDate to, ReportFormat format) {
        // Logika biznesowa nie jest juÅ¼ powiÄ…zana z technicznymi szczegÃ³Å‚ami
        List<SaleData> salesData = repository.fetchSalesData(from, to);

        // ZnajdÅº odpowiedni generator
        ReportGenerator generator = generators.stream()
            .filter(g -> g.supports().equals(format))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Unsupported report format: " + format));

        byte[] report = generator.generate(salesData);
        return report;
    }
}
```

### Podsumowanie korzyÅ›ci z podejÅ›cia DIP

1.  **LuÅºne powiÄ…zania (Loose Coupling):** `ReportService` jest caÅ‚kowicie odizolowany od szczegÃ³Å‚Ã³w implementacyjnych. MoÅ¼emy podmieniaÄ‡ implementacje repozytorium (np. z MySQL na PostgreSQL) lub dodawaÄ‡ nowe generatory raportÃ³w (np. CSV) bez dotykania ani jednej linijki kodu w `ReportService`. Wystarczy zmieniÄ‡ adnotacjÄ™ `@Qualifier` lub dodaÄ‡ nowÄ… klasÄ™ implementujÄ…cÄ… `ReportGenerator`.
2.  **Maksymalna TestowalnoÅ›Ä‡:** Testowanie `ReportService` staje siÄ™ trywialne. W teÅ›cie jednostkowym moÅ¼emy stworzyÄ‡ mocki (atrapy) `SalesRepository` i `ReportGenerator` za pomocÄ… Mockito i wstrzyknÄ…Ä‡ je do serwisu, aby w peÅ‚ni kontrolowaÄ‡ warunki testu.

```java
// PrzykÅ‚ad testu
@Test
void testReportGeneration() {
    SalesRepository mockRepo = Mockito.mock(SalesRepository.class);
    ReportGenerator mockGenerator = Mockito.mock(ReportGenerator.class);

    // Konfiguracja mockÃ³w...
    Mockito.when(mockRepo.fetchSalesData(any(), any())).thenReturn(List.of(new SaleData()));
    Mockito.when(mockGenerator.supports()).thenReturn(ReportFormat.PDF);

    ReportService service = new ReportService(mockRepo, List.of(mockGenerator));

    service.generateSalesReport(LocalDate.now(), LocalDate.now(), ReportFormat.PDF);

    // Weryfikacja, czy mocki zostaÅ‚y poprawnie wywoÅ‚ane...
    Mockito.verify(mockRepo).fetchSalesData(any(), any());
    Mockito.verify(mockGenerator).generate(any());
}
```
3.  **ElastycznoÅ›Ä‡ i ZgodnoÅ›Ä‡ z OCP:** System jest naturalnie otwarty na rozszerzenia. Chcesz dodaÄ‡ raport CSV? StwÃ³rz klasÄ™ `CsvReportGenerator`. `ReportService` nie wymaga zmian.
4.  **CzytelnoÅ›Ä‡:** ModuÅ‚y wysokiego poziomu stajÄ… siÄ™ czystsze, poniewaÅ¼ skupiajÄ… siÄ™ wyÅ‚Ä…cznie na logice biznesowej, delegujÄ…c techniczne detale do wyspecjalizowanych, wymienialnych komponentÃ³w.

**Zasada OdwrÃ³cenia ZaleÅ¼noÅ›ci jest fundamentem nowoczesnego, obiektowego projektowania oprogramowania i kluczem do tworzenia elastycznych, testowalnych i Å‚atwych w utrzymaniu systemÃ³w.** Frameworki takie jak Spring czy Quarkus sÄ… zbudowane po to, aby maksymalnie uÅ‚atwiÄ‡ jej stosowanie.

